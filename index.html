<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Image Viewer Pro (vFinal-Fix)</title>
    <style>
        /* CSS Reset cho di ƒë·ªông */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* T·∫Øt hi·ªáu ·ª©ng x√°m khi b·∫•m v√† gi·ªØ */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background-color: #121212; /* N·ªÅn ƒêEN (Kh√¥ng ph·∫£i tr·∫Øng) */
            color: #ccc;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Ch·∫∑n cu·ªôn trang */
        }

        /* --- M√ÄN H√åNH CH·ªåN FILE --- */
        #welcomeScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #121212;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }
        .upload-btn {
            padding: 20px 40px; background: #333; color: white;
            font-size: 18px; border-radius: 12px; cursor: pointer;
            border: 1px solid #555; text-align: center;
        }
        .upload-btn:active { background: #555; }
        input[type="file"] { display: none; }
        #errorMsg { margin-top: 20px; color: #d32f2f; font-size: 14px; text-align: center; }
        
        /* --- GIAO DI·ªÜN CH√çNH --- */
        #gameUI {
            display: none;
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Viewport */
        #viewport {
            width: 100%;
            height: 100%;
            background-color: #000;
            position: relative;
            overflow: hidden;
            cursor: none;
        }
        #stage {
            position: absolute; top: 0; left: 0;
            transform-origin: 0 0;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        canvas { 
            display: block; 
            transition: opacity 0.1s;
            transform: translateZ(0); 
        }
        
        #statusMsg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 10px 20px; border-radius: 5px;
            display: none; z-index: 200;
        }
        
        /* --- C√îNG C·ª§ HI·ªÇN TH·ªä (Offset Cursor & Loupe) --- */
        #touchCursor {
            position: fixed;
            pointer-events: none;
            border: 2px dashed #FFF;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            display: none;
            transition: width 0.1s, height 0.1s, border-color 0.2s;
        }
        #loupeDiv {
            position: fixed;
            pointer-events: none;
            border: 4px solid #00e5ff;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9998;
            display: none;
            overflow: hidden;
            background-repeat: no-repeat;
        }

        /* --- THANH C√îNG C·ª§ D·ªåC (Sidebar) --- */
        .sidebar-wrapper {
            position: fixed;
            top: 0;
            right: 0; /* M·∫∑c ƒë·ªãnh b√™n ph·∫£i */
            height: 100%;
            display: flex;
            align-items: center;
            z-index: 100;
            transition: transform 0.3s ease-out;
        }
        .sidebar-wrapper.hidden { transform: translateX(100%); }
        .sidebar-wrapper.left.hidden { transform: translateX(-100%); }
        .sidebar-wrapper.left { right: auto; left: 0; }
        
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            height: auto;
            max-height: 95%;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .sidebar-wrapper:not(.left) .sidebar { margin-right: 10px; }
        .sidebar-wrapper.left .sidebar { margin-left: 10px; }
        
        .divider { width: 80%; height: 1px; background: #555; }

        .tool-btn {
            font-size: 20px;
            background: #555;
            color: #fff;
            border: none;
            width: 44px; height: 44px; /* Chu·∫©n c·∫£m ·ª©ng */
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .tool-btn:active { background: #777; }
        
        #hideUIBtn {
            position: absolute;
            top: 50%;
            left: -32px; /* N·∫±m b√™n m√©p tr√°i c·ªßa bar */
            transform: translateY(-50%);
            width: 20px; height: 60px;
            border-radius: 8px 0 0 8px;
            font-size: 16px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
        }
        .sidebar-wrapper.left #hideUIBtn {
            left: auto;
            right: -32px;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }
        
        #showUIBtn {
            position: fixed;
            top: 50%;
            right: 0; /* M·∫∑c ƒë·ªãnh b√™n ph·∫£i */
            transform: translateY(-50%);
            width: 20px; height: 60px;
            border-radius: 8px 0 0 8px;
            font-size: 16px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
            z-index: 99;
            display: none; /* M·∫∑c ƒë·ªãnh ·∫©n */
        }
        #showUIBtn.left {
            right: auto;
            left: 0;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }

        .image-info { 
            font-family: monospace; color: #eee; font-weight: bold;
            font-size: 14px;
        }
        
        .btn-label { font-size: 10px; color: #aaa; margin-top: 5px; }
        .size-display { font-size: 12px; color: #999; margin: 5px 0; }
        
        .tool-btn.active { background: #00e5ff; color: #000; }
        .tool-btn#eraser.active { background: #ff9800; }
        .tool-btn#restore.active { background: #4CAF50; }
        
    </style>
</head>
<body>

    <div id="welcomeScreen">
        <label class="upload-btn">
            üìÇ Ch·ªçn ·∫¢nh
            <p style="font-size: 12px; color: #999; margin-top: 5px;">(V√†o album v√† ch·ªçn t·∫•t c·∫£ ·∫£nh ...o.jpg, ...e.jpg)</p>
            <input type="file" id="fileInput" multiple>
        </label>
        <div id="errorMsg"></div>
    </div>

    <div id="gameUI">
        <div id="statusMsg">Loading...</div>

        <div id="viewport">
            <div id="stage">
                <canvas id="gameCanvas"></canvas>
            </div>
        </div>
        
        <div id="touchCursor"></div>
        <div id="loupeDiv"></div>
        
        <button id="showUIBtn" onclick="toggleUI(true)">‚ü®</button>

        <div class="sidebar-wrapper" id="sidebarWrapper">
            <div class="sidebar">
                <button id="hideUIBtn" onclick="toggleUI(false)">‚ü©</button>
            
                <button class="tool-btn" onclick="prevImage()" title="·∫¢nh tr∆∞·ªõc">‚¨ÖÔ∏è</button>
                <div class="image-info" id="imgCounter">--</div>
                <button class="tool-btn" onclick="nextImage()" title="·∫¢nh sau">‚û°Ô∏è</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" id="loupe" onclick="setTool('loupe')" title="K√≠nh L√∫p">üîé</button>
                <button class="tool-btn" id="eraser" onclick="setTool('eraser')" title="C·ª•c T·∫©y">üßº</button>
                <button class="tool-btn" id="restore" onclick="setTool('restore')" title="Kh√¥i Ph·ª•c">üñåÔ∏è</button>
                <button class="tool-btn" id="viewBtn" ontouchstart="toggleView(true)" ontouchend="toggleView(false)" title="Gi·ªØ ƒë·ªÉ xem Edit">üëÄ</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" onclick="changeBrushSize(20)" title="TƒÉng C·ª°">+</button>
                <span class="size-display" id="brushSizeDisplay">50px</span>
                <button class="tool-btn" onclick="changeBrushSize(-20)" title="Gi·∫£m C·ª°">-</button>
                
                <div class="divider"></div>

                <button class="tool-btn" onclick="resetView()" title="Reset View (Zoom/Pan)">üéØ</button>
                <button class="tool-btn" onclick="resetDrawing()" title="Reset ·∫¢nh (X√≥a v·∫øt t·∫©y)">üîÑ</button>
                <button class="tool-btn" onclick="swapSide()" title="Chuy·ªÉn b√™n Tr√°i/Ph·∫£i">‚ÜîÔ∏è</button>
            </div>
        </div>
    </div>

    <script>
        let filePairs = [];
        let currentIndex = 0;

        // --- DOM Elements ---
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameUI = document.getElementById('gameUI');
        const fileInput = document.getElementById('fileInput');
        const errorMsg = document.getElementById('errorMsg');
        const statusMsg = document.getElementById('statusMsg');

        const viewport = document.getElementById('viewport');
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const imgCounter = document.getElementById('imgCounter');
        
        const touchCursor = document.getElementById('touchCursor');
        const loupeDiv = document.getElementById('loupeDiv');
        const brushSizeDisplay = document.getElementById('brushSizeDisplay');
        const toolButtons = {
            loupe: document.getElementById('loupe'),
            eraser: document.getElementById('eraser'),
            restore: document.getElementById('restore')
        };

        const sidebarWrapper = document.getElementById('sidebarWrapper');
        const hideUIBtn = document.getElementById('hideUIBtn');
        const showUIBtn = document.getElementById('showUIBtn');

        // --- Logic Vars ---
        const imgOriginal = new Image();
        let currentEditURL = '';
        let brushSize = 50;
        let scale = 1; let panX = 0; let panY = 0;
        
        const TOUCH_OFFSET_Y = -80; 
        let isDrawing = false; 
        let isGesturing = false;
        
        let lastPanMidpoint = null;
        let lastPinchDist = 0;

        let currentTool = 'loupe';
        let isSwitching = false;

        // --- KH·ªûI ƒê·ªòNG & CH·ªåN FILE (ƒê√É S·ª¨A L·ªñI REGEX) ---
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            let map = {};
            
            // === S·ª¨A L·ªñI ·ªû ƒê√ÇY ===
            // Regex si√™u linh ho·∫°t: T√¨m B·∫§T K·ª≤ T√äN N√ÄO mi·ªÖn l√† k·∫øt th√∫c b·∫±ng o/e.jpg
            const fileRegex = /(.+)(o|e)\.(jpg|jpeg|png|webp)$/i; 

            files.forEach(f => {
                let m = f.name.toLowerCase().match(fileRegex);
                if (m) {
                    let id = m[1]; // T√™n file (VD: "1", "QP", "File_01")
                    let type = m[2].toLowerCase(); // 'o' ho·∫∑c 'e'
                    if (!map[id]) map[id] = {};
                    map[id][type] = f;
                }
            });
            
            filePairs = [];
            for (let id in map) {
                if (map[id].o && map[id].e) {
                    filePairs.push({ id: id, o: map[id].o, e: map[id].e });
                }
            }
            
            // S·∫Øp x·∫øp theo t√™n (chu·∫©n t·ª± nhi√™n, 1, 2, 10, QP...)
            filePairs.sort((a, b) => a.id.localeCompare(b.id, undefined, {numeric: true, sensitivity: 'base'}));

            if (filePairs.length > 0) {
                welcomeScreen.style.display = 'none';
                gameUI.style.display = 'flex';
                currentIndex = 0;
                setTool('loupe'); // ƒê·∫∑t tool m·∫∑c ƒë·ªãnh
                loadPair(currentIndex);
            } else {
                errorMsg.innerText = "Kh√¥ng t√¨m th·∫•y c·∫∑p ·∫£nh n√†o (v√≠ d·ª•: QPo.jpg v√† QPe.jpg)";
            }
        });

        // --- LOAD ·∫¢NH (ƒê√É S·ª¨A L·ªñI RACE CONDITION) ---
        function loadPair(idx) {
            if (idx < 0 || idx >= filePairs.length) { isSwitching = false; return; }
            statusMsg.style.display = 'block';
            const item = filePairs[idx];
            
            // D·ªçn d·∫πp URL c≈© (n·∫øu c√≥) ƒë·ªÉ ti·∫øt ki·ªám b·ªô nh·ªõ iPad
            if (imgOriginal.src.startsWith('blob:')) URL.revokeObjectURL(imgOriginal.src);
            if (currentEditURL.startsWith('blob:')) URL.revokeObjectURL(currentEditURL);

            const urlO = URL.createObjectURL(item.o);
            currentEditURL = URL.createObjectURL(item.e); // L∆∞u URL ·∫£nh Edit

            // 1. G·∫Øn h√†m x·ª≠ l√Ω 'onload' TR∆Ø·ªöC
            imgOriginal.onload = () => {
                canvas.width = imgOriginal.naturalWidth;
                canvas.height = imgOriginal.naturalHeight;
                stage.style.width = canvas.width + "px";
                stage.style.height = canvas.height + "px";
                
                stage.style.backgroundImage = `url('${currentEditURL}')`;
                loupeDiv.style.backgroundImage = `url('${currentEditURL}')`;
                
                resetView();
                drawFullOriginal(); // V·∫Ω ·∫£nh G·ªëc
                statusMsg.style.display = 'none';
                isSwitching = false; // M·ªü kh√≥a
            };
            // 2. G·∫Øn h√†m x·ª≠ l√Ω l·ªói
            imgOriginal.onerror = () => { 
                statusMsg.style.display = 'none';
                isSwitching = false;
                alert(`L·ªói: Kh√¥ng th·ªÉ t·∫£i file ${item.o.name}`);
             };
            // 3. C·∫≠p nh·∫≠t text
            imgCounter.innerText = `${item.id} (${idx + 1}/${filePairs.length})`;
            
            // 4. Ra l·ªánh t·∫£i
            imgOriginal.src = urlO;
        }

        // --- H√ÄM V·∫º & RESET ---
        function drawFullOriginal() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, canvas.width, canvas.height); // X√≥a v·∫øt c≈©
            ctx.drawImage(imgOriginal, 0, 0, canvas.width, canvas.height);
        }

        function resetDrawing() {
            if (confirm("X√≥a m·ªçi v·∫øt t·∫©y v√† kh√¥i ph·ª•c ·∫£nh g·ªëc?")) {
                drawFullOriginal();
            }
        }

        function resetView() {
            const vW = viewport.clientWidth; const vH = viewport.clientHeight;
            const sW = vW / canvas.width; const sH = vH / canvas.height;
            scale = Math.min(sW, sH, 1) * 0.95;
            panX = (vW - canvas.width * scale) / 2;
            panY = (vH - canvas.height * scale) / 2;
            updateTransform();
            updateToolSize();
        }

        function updateTransform() {
            const transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            stage.style.transform = transform;
            
            // ƒê·ªìng b·ªô K√≠nh L√∫p v·ªõi Pan/Zoom c·ªßa ·∫£nh
            loupeDiv.style.backgroundSize = `${canvas.width * scale}px ${canvas.height * scale}px`;
        }

        // --- THANH C√îNG C·ª§ & ƒêI·ªÄU KHI·ªÇN ---
        
        function changeBrushSize(amount) {
            brushSize += amount;
            if (brushSize < 10) brushSize = 10;
            if (brushSize > 500) brushSize = 500;
            updateToolSize();
        }
        
        function updateToolSize() {
            brushSizeDisplay.innerText = brushSize + "px";
            touchCursor.style.width = brushSize + "px";
            touchCursor.style.height = brushSize + "px";
            loupeDiv.style.width = brushSize + "px";
            loupeDiv.style.height = brushSize + "px";
        }

        function nextImage() {
            if (isSwitching) return;
            if (currentIndex < filePairs.length - 1) {
                isSwitching = true;
                currentIndex++;
                loadPair(currentIndex);
            }
        }
        function prevImage() {
            if (isSwitching) return;
            if (currentIndex > 0) {
                isSwitching = true;
                currentIndex--;
                loadPair(currentIndex);
            }
        }

        function setTool(toolName) {
            currentTool = toolName;
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            if (toolButtons[toolName]) toolButtons[toolName].classList.add('active');
            
            if (toolName === 'loupe') touchCursor.style.borderColor = '#00e5ff';
            else if (toolName === 'eraser') touchCursor.style.borderColor = '#ff9800';
            else if (toolName === 'restore') touchCursor.style.borderColor = '#4CAF50';
        }

        function toggleView(showEdit) {
            canvas.style.opacity = showEdit ? '0' : '1';
        }

        function toggleUI(show) {
            if (show) {
                sidebarWrapper.classList.remove('hidden');
                showUIBtn.style.display = 'none';
            } else {
                sidebarWrapper.classList.add('hidden');
                showUIBtn.style.display = 'block';
            }
        }

        function swapSide() {
            sidebarWrapper.classList.toggle('left');
            showUIBtn.classList.toggle('left');
            if (sidebarWrapper.classList.contains('left')) {
                hideUIBtn.innerHTML = '‚ü®';
            } else {
                hideUIBtn.innerHTML = '‚ü©';
            }
        }

        // --- X·ª¨ L√ù C·∫¢M ·ª®NG (TOUCH) ---
        
        function getPosOnImage(clientX, clientY) {
            const r = viewport.getBoundingClientRect();
            const viewX = clientX - r.left;
            const viewY = clientY - r.top;
            return { 
                x: (viewX - panX) / scale, 
                y: (viewY - panY) / scale 
            };
        }

        function applyTool(clientX, clientY) {
            // 1. T√≠nh t·ªça ƒë·ªô "ch·∫°m l·ªách" (n∆°i c√¥ng c·ª• xu·∫•t hi·ªán)
            const toolX = clientX;
            const toolY = clientY + TOUCH_OFFSET_Y;
            
            // 2. Hi·ªÉn th·ªã v√≤ng tr√≤n ·∫£o t·∫°i ƒë√≥
            touchCursor.style.left = toolX + 'px';
            touchCursor.style.top = toolY + 'px';
            touchCursor.style.display = 'block';
            
            // 3. T√≠nh t·ªça ƒë·ªô t∆∞∆°ng ·ª©ng tr√™n ·∫£nh
            const imgPos = getPosOnImage(toolX, toolY);
            
            // T·∫©y/Kh√¥i ph·ª•c ph·∫£i chia cho scale, v√¨ n√©t v·∫Ω n·∫±m tr√™n canvas ƒë√£ b·ªã scale
            const drawRadius = brushSize / 2 / scale;

            if (currentTool === 'loupe') {
                loupeDiv.style.left = toolX + 'px';
                loupeDiv.style.top = toolY + 'px';
                loupeDiv.style.display = 'block';
                const bgX = (-imgPos.x * scale) + (brushSize / 2);
                const bgY = (-imgPos.y * scale) + (brushSize / 2);
                loupeDiv.style.backgroundPosition = `${bgX}px ${bgY}px`;
                
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, drawRadius, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (currentTool === 'restore') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, drawRadius, 0, Math.PI * 2);
                ctx.save();
                ctx.clip();
                ctx.drawImage(imgOriginal, 0, 0);
                ctx.restore();
            }
        }
        
        // --- B·ªò L·∫ÆNG NGHE S·ª∞ KI·ªÜN TOUCH ---

        viewport.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                e.preventDefault();
                isDrawing = true;
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                e.preventDefault();
                isDrawing = false; 
                isGesturing = true;
                
                touchCursor.style.display = 'none';
                loupeDiv.style.display = 'none';

                lastPanMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                lastPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', e => {
            e.preventDefault();
            
            if (isDrawing && e.touches.length === 1) {
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (isGesturing && e.touches.length === 2) {
                
                // 1. Pan
                const newMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                panX += newMidpoint.x - lastPanMidpoint.x;
                panY += newMidpoint.y - lastPanMidpoint.y;
                lastPanMidpoint = newMidpoint;

                // 2. Zoom
                const newPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
                // Tr√°nh l·ªói chia cho 0
                if (lastPinchDist === 0) lastPinchDist = newPinchDist;
                
                const scaleDelta = newPinchDist / lastPinchDist;
                
                const newScale = scale * scaleDelta;
                if (newScale >= 0.1 && newScale <= 50) {
                    const rect = viewport.getBoundingClientRect();
                    const mx = newMidpoint.x - rect.left;
                    const my = newMidpoint.y - rect.top;
                    
                    panX = mx - (mx - panX) * scaleDelta;
                    panY = my - (my - panY) * scaleDelta;
                    scale = newScale;
                }
                lastPinchDist = newPinchDist;

                // 3. C·∫≠p nh·∫≠t
                updateTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', e => {
            isDrawing = false;
            isGesturing = false;
            lastPanMidpoint = null;
            
            touchCursor.style.display = 'none';
            loupeDiv.style.display = 'none';
        });

    </script>
</body>
</html>
