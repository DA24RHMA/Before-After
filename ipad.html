<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Image Viewer Pro (vFinal)</title>
    <style>
        /* CSS Reset cho di ƒë·ªông */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* T·∫Øt hi·ªáu ·ª©ng x√°m khi b·∫•m v√† gi·ªØ */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        body {
            background-color: #121212;
            color: #ccc;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden; /* Ch·∫∑n cu·ªôn trang */
        }

        /* --- M√ÄN H√åNH CH·ªåN FILE --- */
        #welcomeScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #121212;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }
        .upload-btn {
            padding: 20px 40px; background: #333; color: white;
            font-size: 18px; border-radius: 12px; cursor: pointer;
            border: 1px solid #555; text-align: center;
        }
        .upload-btn:active { background: #555; }
        input[type="file"] { display: none; }
        #errorMsg { margin-top: 20px; color: #d32f2f; font-size: 14px; text-align: center; }
        
        /* --- GIAO DI·ªÜN CH√çNH --- */
        #gameUI {
            display: none;
            width: 100%; height: 100%;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Viewport (Khung nh√¨n ch√≠nh) */
        #viewport {
            width: 100%;
            height: 100%;
            background-color: #000;
            position: relative;
            overflow: hidden;
            cursor: none;
        }
        #stage {
            position: absolute; top: 0; left: 0;
            transform-origin: 0 0;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        canvas { 
            display: block; 
            transition: opacity 0.1s;
            transform: translateZ(0); 
        }
        
        #statusMsg {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white;
            padding: 10px 20px; border-radius: 5px;
            display: none; z-index: 200;
        }
        
        /* --- C√îNG C·ª§ HI·ªÇN TH·ªä (Offset Cursor & Loupe) --- */
        
        /* V√≤ng tr√≤n ·∫£o hi·ªÉn th·ªã v·ªã tr√≠ v·∫Ω (Touch Offset) */
        #touchCursor {
            position: fixed;
            pointer-events: none;
            border: 2px dashed #FFF;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            display: none;
            transition: width 0.1s, height 0.1s, border-color 0.2s;
        }
        
        /* V√≤ng K√≠nh L√∫p (Ri√™ng bi·ªát) */
        #loupeDiv {
            position: fixed;
            pointer-events: none;
            border: 4px solid #00e5ff;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 9998;
            display: none;
            overflow: hidden;
            background-repeat: no-repeat;
        }

        /* --- THANH C√îNG C·ª§ D·ªåC (Sidebar) --- */
        .sidebar-wrapper {
            position: fixed;
            top: 0;
            right: 0; /* M·∫∑c ƒë·ªãnh b√™n ph·∫£i */
            height: 100%;
            display: flex;
            align-items: center;
            z-index: 100;
            transition: transform 0.3s ease-out;
        }
        /* Giao di·ªán khi b·ªã ·∫©n */
        .sidebar-wrapper.hidden { transform: translateX(100%); }
        .sidebar-wrapper.left.hidden { transform: translateX(-100%); }
        
        /* Khi chuy·ªÉn sang tr√°i */
        .sidebar-wrapper.left {
            right: auto;
            left: 0;
        }
        
        /* Thanh bar ch√≠nh */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px;
            height: auto;
            max-height: 95%;
            border-radius: 12px;
            border: 1px solid #444;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        /* CƒÉn l·ªÅ cho thanh bar */
        .sidebar-wrapper:not(.left) .sidebar { margin-right: 10px; }
        .sidebar-wrapper.left .sidebar { margin-left: 10px; }
        
        /* V·∫°ch chia nh√≥m */
        .divider {
            width: 80%;
            height: 1px;
            background: #555;
        }

        /* N√∫t b·∫•m tr√™n thanh bar */
        .tool-btn {
            font-size: 20px;
            background: #555;
            color: #fff;
            border: none;
            width: 44px; height: 44px; /* Chu·∫©n c·∫£m ·ª©ng */
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* ƒê·ªÉ hi·ªán label */
        }
        .tool-btn:active { background: #777; }
        
        /* N√∫t ·∫©n/hi·ªán UI */
        #hideUIBtn {
            position: absolute;
            top: 50%;
            left: -32px; /* N·∫±m b√™n m√©p tr√°i c·ªßa bar */
            transform: translateY(-50%);
            width: 20px; height: 60px;
            border-radius: 8px 0 0 8px;
            font-size: 16px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
        }
        .sidebar-wrapper.left #hideUIBtn {
            left: auto;
            right: -32px;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }
        
        /* N√∫t g·ªçi UI ra (khi b·ªã ·∫©n) */
        #showUIBtn {
            position: fixed;
            top: 50%;
            right: 0; /* M·∫∑c ƒë·ªãnh b√™n ph·∫£i */
            transform: translateY(-50%);
            width: 20px; height: 60px;
            border-radius: 8px 0 0 8px;
            font-size: 16px;
            padding: 0;
            background: #333;
            border: 1px solid #444;
            border-right: none;
            z-index: 99;
            display: none; /* M·∫∑c ƒë·ªãnh ·∫©n */
        }
        #showUIBtn.left {
            right: auto;
            left: 0;
            border-radius: 0 8px 8px 0;
            border-right: 1px solid #444;
            border-left: none;
        }

        .image-info { 
            font-family: monospace; color: #eee; font-weight: bold;
            font-size: 14px;
        }
        
        /* Label cho n√∫t */
        .btn-label {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
        }
        .size-display {
            font-size: 12px;
            color: #999;
            margin: 5px 0;
        }
        
        /* N√∫t ƒëang ƒë∆∞·ª£c ch·ªçn */
        .tool-btn.active {
            background: #00e5ff;
            color: #000;
        }
        .tool-btn#eraser.active { background: #ff9800; }
        .tool-btn#restore.active { background: #4CAF50; }
        
    </style>
</head>
<body>

    <div id="welcomeScreen">
        <label class="upload-btn">
            üìÇ Ch·ªçn ·∫¢nh
            <p style="font-size: 12px; color: #999; margin-top: 5px;">(V√†o album v√† ch·ªçn t·∫•t c·∫£ ·∫£nh 1o, 1e, 2o, 2e...)</p>
            <input type="file" id="fileInput" multiple>
        </label>
        <div id="errorMsg"></div>
    </div>

    <div id="gameUI">
        <div id="statusMsg">Loading...</div>

        <div id="viewport">
            <div id="stage">
                <canvas id="gameCanvas"></canvas>
            </div>
        </div>
        
        <div id="touchCursor"></div>
        <div id="loupeDiv"></div>
        
        <button id="showUIBtn" onclick="toggleUI(true)">‚ü®</button>

        <div class="sidebar-wrapper" id="sidebarWrapper">
            <div class="sidebar">
                <button id="hideUIBtn" onclick="toggleUI(false)">‚ü©</button>
            
                <button class="tool-btn" onclick="prevImage()" title="·∫¢nh tr∆∞·ªõc">‚¨ÖÔ∏è</button>
                <div class="image-info" id="imgCounter">--</div>
                <button class="tool-btn" onclick="nextImage()" title="·∫¢nh sau">‚û°Ô∏è</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" id="loupe" onclick="setTool('loupe')" title="K√≠nh L√∫p">üîé</button>
                <button class="tool-btn" id="eraser" onclick="setTool('eraser')" title="C·ª•c T·∫©y">üßº</button>
                <button class="tool-btn" id="restore" onclick="setTool('restore')" title="Kh√¥i Ph·ª•c">üñåÔ∏è</button>
                <button class="tool-btn" id="viewBtn" ontouchstart="toggleView(true)" ontouchend="toggleView(false)" title="Gi·ªØ ƒë·ªÉ xem Edit">üëÄ</button>
                
                <div class="divider"></div>
                
                <button class="tool-btn" onclick="changeBrushSize(20)" title="TƒÉng C·ª°">+</button>
                <span class="size-display" id="brushSizeDisplay">50px</span>
                <button class="tool-btn" onclick="changeBrushSize(-20)" title="Gi·∫£m C·ª°">-</button>
                
                <div class="divider"></div>

                <button class="tool-btn" onclick="resetView()" title="Reset View (Zoom/Pan)">üéØ</button>
                <button class="tool-btn" onclick="resetDrawing()" title="Reset ·∫¢nh (X√≥a v·∫øt t·∫©y)">üîÑ</button>
                <button class="tool-btn" onclick="swapSide()" title="Chuy·ªÉn b√™n Tr√°i/Ph·∫£i">‚ÜîÔ∏è</button>
            </div>
        </div>
    </div>

    <script>
        let filePairs = [];
        let currentIndex = 0;

        // --- DOM Elements ---
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameUI = document.getElementById('gameUI');
        const fileInput = document.getElementById('fileInput');
        const errorMsg = document.getElementById('errorMsg');
        const statusMsg = document.getElementById('statusMsg');

        const viewport = document.getElementById('viewport');
        const stage = document.getElementById('stage');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const imgCounter = document.getElementById('imgCounter');
        
        // C√¥ng c·ª•
        const touchCursor = document.getElementById('touchCursor');
        const loupeDiv = document.getElementById('loupeDiv');
        const brushSizeDisplay = document.getElementById('brushSizeDisplay');
        const toolButtons = {
            loupe: document.getElementById('loupe'),
            eraser: document.getElementById('eraser'),
            restore: document.getElementById('restore')
        };

        // UI Bar
        const sidebarWrapper = document.getElementById('sidebarWrapper');
        const hideUIBtn = document.getElementById('hideUIBtn');
        const showUIBtn = document.getElementById('showUIBtn');

        // --- Logic Vars ---
        const imgOriginal = new Image();
        let currentEditURL = ''; // L∆∞u URL ·∫£nh Edit
        let brushSize = 50;
        let scale = 1; let panX = 0; let panY = 0;
        
        // Touch
        const TOUCH_OFFSET_Y = -80; // ƒê·ªô l·ªách c·ªßa c√¥ng c·ª• so v·ªõi ng√≥n tay
        let isDrawing = false; // ƒêang v·∫Ω 1 ng√≥n
        let isGesturing = false; // ƒêang zoom/pan 2 ng√≥n
        
        // Pan 2 ng√≥n
        let lastPanMidpoint = null;
        // Zoom 2 ng√≥n
        let lastPinchDist = 0;

        let currentTool = 'loupe';
        let isSwitching = false;

        // --- KH·ªûI ƒê·ªòNG & CH·ªåN FILE ---
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            let map = {};
            const fileRegex = /(\d+)(o|e)\.(jpg|jpeg|png|webp)$/i;
            files.forEach(f => {
                let m = f.name.toLowerCase().match(fileRegex);
                if (m) {
                    let id = parseInt(m[1]); let type = m[2].toLowerCase();
                    if (!map[id]) map[id] = {};
                    if (!map[id][type] || f.name.length < map[id][type].name.length) map[id][type] = f;
                }
            });
            filePairs = [];
            for (let id in map) {
                if (map[id].o && map[id].e) filePairs.push({ id: parseInt(id), o: map[id].o, e: map[id].e });
            }
            filePairs.sort((a, b) => a.id - b.id);

            if (filePairs.length > 0) {
                welcomeScreen.style.display = 'none';
                gameUI.style.display = 'flex';
                currentIndex = 0;
                setTool('loupe'); // ƒê·∫∑t tool m·∫∑c ƒë·ªãnh
                loadPair(currentIndex);
            } else {
                errorMsg.innerText = "Kh√¥ng t√¨m th·∫•y c·∫∑p ·∫£nh n√†o (v√≠ d·ª•: 1o.jpg v√† 1e.jpg)";
            }
        });

        // --- LOAD ·∫¢NH ---
        function loadPair(idx) {
            if (idx < 0 || idx >= filePairs.length) { isSwitching = false; return; }
            statusMsg.style.display = 'block';
            const item = filePairs[idx];
            const urlO = URL.createObjectURL(item.o);
            currentEditURL = URL.createObjectURL(item.e); // L∆∞u URL ·∫£nh Edit

            imgOriginal.onload = () => {
                canvas.width = imgOriginal.naturalWidth;
                canvas.height = imgOriginal.naturalHeight;
                stage.style.width = canvas.width + "px";
                stage.style.height = canvas.height + "px";
                
                // ƒê·∫∑t n·ªÅn cho Stage (l·ªõp d∆∞·ªõi)
                stage.style.backgroundImage = `url('${currentEditURL}')`;
                
                // ƒê·∫∑t n·ªÅn cho K√≠nh L√∫p (l·ªõp tr√™n)
                loupeDiv.style.backgroundImage = `url('${currentEditURL}')`;
                
                resetView();
                drawFullOriginal(); // V·∫Ω ·∫£nh Original
                statusMsg.style.display = 'none';
                isSwitching = false;
            };
            imgOriginal.onerror = () => { /*...*/ };
            imgCounter.innerText = `${item.id} (${idx + 1}/${filePairs.length})`;
            imgOriginal.src = urlO;
        }

        // --- H√ÄM V·∫º & RESET ---
        function drawFullOriginal() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(imgOriginal, 0, 0, canvas.width, canvas.height);
        }

        function resetDrawing() {
            if (confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a h·∫øt v·∫øt t·∫©y v√† kh√¥i ph·ª•c ·∫£nh g·ªëc?")) {
                drawFullOriginal();
            }
        }

        function resetView() {
            const vW = viewport.clientWidth; const vH = viewport.clientHeight;
            const sW = vW / canvas.width; const sH = vH / canvas.height;
            scale = Math.min(sW, sH, 1) * 0.95;
            panX = (vW - canvas.width * scale) / 2;
            panY = (vH - canvas.height * scale) / 2;
            updateTransform();
            updateToolSize();
        }

        function updateTransform() {
            const transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            stage.style.transform = transform;
            
            // ƒê·ªìng b·ªô K√≠nh L√∫p v·ªõi Pan/Zoom c·ªßa ·∫£nh
            loupeDiv.style.backgroundSize = `${canvas.width * scale}px ${canvas.height * scale}px`;
        }

        // --- THANH C√îNG C·ª§ & ƒêI·ªÄU KHI·ªÇN ---
        
        function changeBrushSize(amount) {
            brushSize += amount;
            if (brushSize < 10) brushSize = 10;
            if (brushSize > 500) brushSize = 500;
            updateToolSize();
        }
        
        // C·∫≠p nh·∫≠t k√≠ch th∆∞·ªõc (v√† text)
        function updateToolSize() {
            brushSizeDisplay.innerText = brushSize + "px";
            touchCursor.style.width = brushSize + "px";
            touchCursor.style.height = brushSize + "px";
            loupeDiv.style.width = brushSize + "px";
            loupeDiv.style.height = brushSize + "px";
        }

        function nextImage() {
            if (isSwitching) return;
            if (currentIndex < filePairs.length - 1) {
                isSwitching = true;
                currentIndex++;
                loadPair(currentIndex);
            }
        }
        function prevImage() {
            if (isSwitching) return;
            if (currentIndex > 0) {
                isSwitching = true;
                currentIndex--;
                loadPair(currentIndex);
            }
        }

        // ƒê·ªïi Tool (L√∫p, T·∫©y, Kh√¥i ph·ª•c)
        function setTool(toolName) {
            currentTool = toolName;
            
            // X√≥a active ·ªü t·∫•t c·∫£
            Object.values(toolButtons).forEach(btn => btn.classList.remove('active'));
            
            // Th√™m active cho n√∫t ƒë∆∞·ª£c ch·ªçn
            if (toolButtons[toolName]) {
                toolButtons[toolName].classList.add('active');
            }
            
            // C·∫≠p nh·∫≠t m√†u v√≤ng tr√≤n ·∫£o
            if (toolName === 'loupe') touchCursor.style.borderColor = '#00e5ff';
            else if (toolName === 'eraser') touchCursor.style.borderColor = '#ff9800';
            else if (toolName === 'restore') touchCursor.style.borderColor = '#4CAF50';
        }

        // Gi·ªØ ƒë·ªÉ xem ·∫£nh Edit
        function toggleView(showEdit) {
            canvas.style.opacity = showEdit ? '0' : '1';
        }

        // ·∫®n/Hi·ªán thanh Bar
        function toggleUI(show) {
            if (show) {
                sidebarWrapper.classList.remove('hidden');
                showUIBtn.style.display = 'none';
            } else {
                sidebarWrapper.classList.add('hidden');
                showUIBtn.style.display = 'block';
            }
        }

        // ƒê·ªïi b√™n Tr√°i/Ph·∫£i
        function swapSide() {
            sidebarWrapper.classList.toggle('left');
            showUIBtn.classList.toggle('left');
            // C·∫≠p nh·∫≠t l·∫°i n√∫t ·∫®n (v√¨ n√∫t n√†y n·∫±m b√™n trong bar)
            if (sidebarWrapper.classList.contains('left')) {
                hideUIBtn.innerHTML = '‚ü®';
            } else {
                hideUIBtn.innerHTML = '‚ü©';
            }
        }

        // --- X·ª¨ L√ù C·∫¢M ·ª®NG (TOUCH) ---
        
        // H√†m t√≠nh t·ªça ƒë·ªô t∆∞∆°ng ƒë·ªëi tr√™n ·∫£nh
        function getPosOnImage(clientX, clientY) {
            const r = viewport.getBoundingClientRect();
            // T·ªça ƒë·ªô t∆∞∆°ng ƒë·ªëi so v·ªõi viewport
            const viewX = clientX - r.left;
            const viewY = clientY - r.top;
            // T·ªça ƒë·ªô th·ª±c tr√™n ·∫£nh (ƒë√£ tr·ª´ pan/zoom)
            return { 
                x: (viewX - panX) / scale, 
                y: (viewY - panY) / scale 
            };
        }

        // H√†m √°p d·ª•ng c√¥ng c·ª• (V·∫Ω, T·∫©y, L√∫p)
        function applyTool(clientX, clientY) {
            // 1. T√≠nh t·ªça ƒë·ªô "ch·∫°m l·ªách" (n∆°i c√¥ng c·ª• xu·∫•t hi·ªán)
            const toolX = clientX;
            const toolY = clientY + TOUCH_OFFSET_Y;
            
            // 2. Hi·ªÉn th·ªã v√≤ng tr√≤n ·∫£o t·∫°i ƒë√≥
            touchCursor.style.left = toolX + 'px';
            touchCursor.style.top = toolY + 'px';
            touchCursor.style.display = 'block';
            
            // 3. T√≠nh t·ªça ƒë·ªô t∆∞∆°ng ·ª©ng tr√™n ·∫£nh
            const imgPos = getPosOnImage(toolX, toolY);
            
            if (currentTool === 'loupe') {
                // Di chuy·ªÉn K√≠nh L√∫p
                loupeDiv.style.left = toolX + 'px';
                loupeDiv.style.top = toolY + 'px';
                loupeDiv.style.display = 'block';
                // CƒÉn n·ªÅn c·ªßa K√≠nh L√∫p
                const bgX = (-imgPos.x * scale) + (brushSize / 2);
                const bgY = (-imgPos.y * scale) + (brushSize / 2);
                loupeDiv.style.backgroundPosition = `${bgX}px ${bgY}px`;
                
            } else if (currentTool === 'eraser') {
                // T·∫©y (ƒê·ª•c l·ªó canvas)
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, brushSize / 2 / scale, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (currentTool === 'restore') {
                // Kh√¥i ph·ª•c (V·∫Ω l·∫°i ·∫£nh g·ªëc)
                ctx.globalCompositeOperation = 'source-over';
                ctx.beginPath();
                ctx.arc(imgPos.x, imgPos.y, brushSize / 2 / scale, 0, Math.PI * 2);
                ctx.save();
                ctx.clip(); // Ch·ªâ v·∫Ω trong v√≤ng tr√≤n
                ctx.drawImage(imgOriginal, 0, 0);
                ctx.restore();
            }
        }
        
        // --- B·ªò L·∫ÆNG NGHE S·ª∞ KI·ªÜN TOUCH ---

        viewport.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                // 1 ng√≥n: B·∫Øt ƒë·∫ßu v·∫Ω
                e.preventDefault();
                isDrawing = true;
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (e.touches.length === 2) {
                // 2 ng√≥n: B·∫Øt ƒë·∫ßu Pan/Zoom
                e.preventDefault();
                isDrawing = false; // Ng·ª´ng v·∫Ω
                isGesturing = true;
                
                // ·∫®n c√¥ng c·ª•
                touchCursor.style.display = 'none';
                loupeDiv.style.display = 'none';

                // L∆∞u ƒëi·ªÉm b·∫Øt ƒë·∫ßu Pan
                lastPanMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                // L∆∞u kho·∫£ng c√°ch b·∫Øt ƒë·∫ßu Zoom
                lastPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', e => {
            e.preventDefault();
            
            if (isDrawing && e.touches.length === 1) {
                // 1 ng√≥n: ƒêang v·∫Ω
                applyTool(e.touches[0].clientX, e.touches[0].clientY);
                
            } else if (isGesturing && e.touches.length === 2) {
                // 2 ng√≥n: ƒêang Pan/Zoom
                
                // 1. T√≠nh to√°n Pan
                const newMidpoint = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                panX += newMidpoint.x - lastPanMidpoint.x;
                panY += newMidpoint.y - lastPanMidpoint.y;
                lastPanMidpoint = newMidpoint; // C·∫≠p nh·∫≠t ƒëi·ªÉm cu·ªëi

                // 2. T√≠nh to√°n Zoom
                const newPinchDist = Math.hypot(
                    e.touches[1].clientX - e.touches[0].clientX,
                    e.touches[1].clientY - e.touches[0].clientY
                );
                const scaleDelta = newPinchDist / lastPinchDist;
                
                // T√≠nh to√°n ƒëi·ªÉm neo ƒë·ªÉ zoom t·∫°i ch·ªó
                const newScale = scale * scaleDelta;
                if (newScale >= 0.1 && newScale <= 50) {
                    const rect = viewport.getBoundingClientRect();
                    const mx = newMidpoint.x - rect.left;
                    const my = newMidpoint.y - rect.top;
                    
                    panX = mx - (mx - panX) * scaleDelta;
                    panY = my - (my - panY) * scaleDelta;
                    scale = newScale;
                }
                lastPinchDist = newPinchDist; // C·∫≠p nh·∫≠t kho·∫£ng c√°ch cu·ªëi

                // 3. C·∫≠p nh·∫≠t giao di·ªán
                updateTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', e => {
            isDrawing = false;
            isGesturing = false;
            lastPanMidpoint = null;
            
            // ·∫®n c√¥ng c·ª•
            touchCursor.style.display = 'none';
            loupeDiv.style.display = 'none';
        });

    </script>
</body>
</html>
